# 嵌入式

## 概述

### 嵌入式系统的定义：

以==应用==为中心、以==计算机技术==为基础，软、硬件==可裁剪==，适应应用系统对功能、可靠性、成本、体积、功耗等==严格要求的**专用计算机系统**==。广义的讲，凡是==带有智能处理器的专用软硬件系统==都可称为嵌入式系统。

### 特点（ 嵌入式系统和通用计算机系统的区别）

- ==系统内核小（资源有限）==；
- ==专用性强==；
- ==运行环境差异大==；
- ==可靠性要求高（无人值守）==；
- 通常要求有==高实时性==的操作系统；
- 具有固化在非易失性存储器中的代码；
- 嵌入式系统开发需要专门的开发工具和环境；
- 一旦进入市场，就具有较长的生命周期；

### 嵌入式处理器的分类

- 嵌入式微控制器（单片机）

  - 内部集成了 ROM、RAM、总线、定时器、I/O
  - 微控制器的片上外设资源丰富，适合用于控制

- 嵌入式微处理器

  - 具有 32 位以上的总线，只保留与嵌入式应用紧密相关的功能硬件
  - 与嵌入式微控制器的区别：==微控制器存储器在片内==、==微处理器存储器在片外==

- 嵌入式 DSP

  专门用于信号处理方面的处理器，在系统结构和指令算法方面进行了特殊设计，配有专用的硬件

- SOC

  将通用处理器的IP核和功能模块的IP核按用户要求组成系统

- SOPC

  整个系统放在一个硅片上

### 嵌入式系统的分类

**实时操作系统：** ==计算的正确性不仅取决于程序的逻辑正确性，更取决于结果产生的时间 （确定性）==

- 非实时系统
- 软实时系统（消费类产品）
- 硬实时系统（工业和军工系统）



# 2. 嵌入式系统简介

计算机两种体系结构的区别、控制器的组成方式、流水线、缓存的作用、risc cisc 区别特点（课件上的对比表）、轮询、前后台系统、事件驱动的编程模型

## 两种体系结构

- ==**冯诺依曼体系结构**==
  - ==数据与指令都存储在存储器==中
    - 程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置；因此==程序指令和数据的宽度==相同。
  - ==ARM7==
- **==哈佛体系结构==**
  - ==程序存储器与数据存储器分开==
    - 使用两个独立的存储器模块，==指令和数据可以有不同的数据宽度==
    - 适用于数字信号处理
  - ==ARM 9==

## 控制器的组成方式

- **==组合逻辑型==：** 快、复杂
- **==存储逻辑型==：** 慢、规整（基于微指令）

## 影响性能的因素

- **流水线技术**：

  - 几个指令可以并行执行
  - 提高了 CPU 的运行效率
  - 内部信息流要求通畅流动

- **缓存**

  微处理器的时钟频率比内存速度快得多，高速缓存可以提高内存的平均性能

### CISC 与 RISC

| 指 标              | RISC                                                         | CISC                                 |
| ------------------ | ------------------------------------------------------------ | ------------------------------------ |
| **指令集**         | 一个周期执行一条指令，通过简单指令的组合实现复杂操作；指令长度固定 | 指令长度不固定，执行需要多个周期     |
| **流水线**         | 每周期前进一步                                               | 指令的执行需要调用微代码的一个微程序 |
| **寄存器**         | 更多通用寄存器                                               | 用于特定目的的专用寄存器             |
| **Load/Store结构** | 独立的Load/Store指令完成数据在寄存器和外部存储器之间的传输   | 处理器能够直接处理存储器中的数据     |

## 多任务程序结构

### 前后台程序结构

- 前台
  - ==中断==实现
  - ==处理对时间要求严格的事件、突发事件==
- 后台：
  - ==轮询==多任务实现
  - ==处理对时间要求不严格的事件==

### 事件触发结构（事件驱动）

- 在状态中判断事件 （事件查询）
- 在事件中判断状态（事件触发）：在每个事件的中断函数内，判断当前状态，根据当前状态执行不同动作

### 操作系统



# 3. ARM 编程模型

- ARM 命名 的三个系列的区别 (A、R、M）A系列的代号 M3、M4 R系列
- ARM 内部的两个状态和七种模式（用户模式、系统模式、异常模式）
- 模式对应的多个寄存器 （16个寄存器）几种异常 （备份）（快速中断）
- R15 PC指针、堆栈指针等

## ARM

> ARM =  Advanced RISC  Machines， ARM是Advanced RISC Machines的缩写，它是一家微处理器行业的知名企业，该企业设计了大量高性能、廉价、耗能低的RISC （精简指令集）处理器。公司的特点是只设计芯片，而不生产。它将技术授权给世界上许多著名的半导体、软件和OEM厂商，并提供服务。

### ARM 系列处理器

- **ARM 7 系列：** 采用ARMV4T（Neuman）结构，分为**三级流水**，支持**16位的Thumb指令集**
- **ARM 9 系列：** 采用ARMV4T （Harvard）结构，**五级流水**处理以及**分离的Cache结构**
- **Cortex 系列：**
  - **Cortex A**：面向==尖端==的基于虚拟内存的操作系统和用户应用，如应用像Linux、Windows
    CE和Symbian等操作系统的消费娱乐产品和无线产品
  - **Cortex R：**面向需要运行==实时操作系统==来进行控制应用的系统，包括汽车电子、网络和影像系统 
  - **Cortex M：**面向那些对开发==费用非常敏感==同时对性能要求不断增加的嵌入式应用(如微控制器、汽车车身控制系统和各种大型家电)

## ARM 处理器的工作状态

- **ARM 状态：** 处理器执行==32位的字对齐的ARM指令==；
- **Thumb 状态：** 执行==16位的、半字对齐的 Thumb 指令==；

可以随时在两种工作状态间切换

### 七种模式

| 处理器模式     | 说明                            | 备注                                               |
| -------------- | ------------------------------- | -------------------------------------------------- |
| 用户 (usr)     | 正常程序工作模式                | 不能直接切换到其它模式                             |
| 系统 (sys)     | 用于支持操作系统的特权任务等    | 与用户模式类似，但具有可以直接切换到其它模式等特权 |
| 快中断   (fiq) | 支持高速数据传输及通道处理      | FIQ异常响应时进入此模式                            |
| 中断 (irq)     | 用于通用中断处理                | IRQ异常响应时进入此模式                            |
| 管理 (svc)     | 操作系统保护代码                | 系统复位和软件中断响应时进入此模式                 |
| 中止 (abt)     | 用于支持虚拟内存和/或存储器保护 | 在ARM7TDMI没有多大用处                             |
| 未定义   (und) | 支持硬件协处理器的软件仿真      | 未定义指令异常响应时进入此模式                     |

- **特权模式：** 除了用户模式之外，其他模式都是特权模式
  - 系统模式与用户模式有完全相同的寄存器组，操作系统任务可访问所有需要的系统资源而不受用户模式限制。
- **异常模式：** 除了系统模式之外的特权模式都是异常模式
  - 当应用程序发生异常中断时，处理器进入相应的异常模式。
  - 每一种异常模式中都有某些附加的影子寄存器组供相应的异常处理程序使用。

## 寄存器组织

![mark](http://media.sumblog.cn/blog/20190105/mYOmz01bhDEL.png?imageslim)

- R0～R13为保存数据或地址值的通用寄存器。它们是完全通用的寄存器，不会被体系结构作为特殊用途，并且可用于任何使用通用寄存器的指令。
  - 其中R0～R7为未分组的寄存器，也就是说对于任何处理器模式，这些寄存器都对应于相同的32位物理寄存器。
  - 寄存器R8～R14为分组寄存器。它们所对应的物理寄存器取决于当前的处理器模式，几乎所有允许使用通用寄存器的指令都允许使用分组寄存器
  - 寄存器R8～R12有两个分组的物理寄存器。一个用于除FIQ模式之外的所有寄存器模式，另一个用于FIQ模式。这样在发生FIQ中断后，可以加速FIQ的处理速度。
  - 寄存器R13、R14分别有6个分组的物理寄存器。一个用于用户和系统模式，其余5个分别用于5种异常模式。
  - 寄存器R13常作为堆栈指针（SP）。在ARM指令集当中，没有以特殊方式使用R13的指令或其它功能，只是习惯上都这样使用。在Thumb指令集中存在使用R13的指令。
- ==R14为链接寄存器（LR）==，在结构上有两个特殊功能：
  - 在每种模式下，模式自身的R14版本用于**保存子程序返回地址**；
  - 当发生异常时，将R14对应的异常模式版本设置为**异常返回地址**（有些异常有一个小的固定偏移量）。
- ==寄存器R15为程序计数器（PC）==，它指向正在取指的地址。可以认为它是一个通用寄存器，但是对于它的使用有许多与指令相关的限制或特殊情况。
- ==寄存器CPSR为程序状态寄存器==，在异常模式中，另外一个寄存器“程序状态保存寄存器（SPSR）”可以被访问。每种异常都有自己的SPSR，在因为异常事件而进入异常时它保存CPSR的当前值，异常退出时可通过它恢复CPSR。

## 

# 4. ARM 指令

- 寻址方式：
  - 与 8086 对比
  - 立即数寻址方式
  - 寄存器寻址、寄存器移位寻址
  - 间接寻址
- **指令：**
  - 不用背
  - 考试以程序方式给出
  - 考核简单常用指令
- 汇编：
  - 理解为主
  - 伪操作、伪指令的特点
  - 怎么定义数、变量、如何引用文件、入口、常量
  - 难度类似于课件中汇编的例子
  - 怎么定义一个段、end、 标号、跳转
  - 汇编一定会涉及
  - 绝对没有问题

## 寻址方式

- **立即寻址**：操作数就包含在指令的32位编码中

  - ==立即数使用 `#` 作为前缀==

  ```assembly
  ADD	R0，R0，#1
  AND	R3，R4，#0xFF
  ```

  - ==用 12 位数据表示 32 位数据空间==，每个立即数都由一个==8位常数==循环右移==偶数位==得到

    - 8(常数）+ 4（偶数移位个数）= 12

    > 合法的立即数
    >
    > 0xF200  (0b==1111_0010==_0000_0000)
    >
    > 0x110000(0b==0001_0001==_0000_0000_0000_0000)
    >
    > 0x12800  (0b000==1_0010_1==000_0000_0000_0000)
    >
    > 非法的立即数
    >
    > 0x1010  (0b000==1_0000_0001==_0000)
    >
    > 0x00102  (0b0000_0000_000==1_0000_001==0)
    >
    > 0xFF1000(0b==1111_1111_0001==_0000_0000_0000)

- 寄存器寻址：操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，指令执行时直接取出寄存器值操作。

  ```assembly
  MOV	R1，R2  	 ;R2 -> R1
  SUB	R0，R1，R2 ;R1 - R2 -> R0
  ```

- 寄存器偏移寻址：寄存器移位寻址是ARM指令集特有的寻址方式，是寄存器寻址方式的增强形式

  ```assembly
  MOV R0，R2，LSL #3  ;R2 的值左移3 位，结果放入R0，即R0 = R2 * 8
  ANDS R1，R1，R2，LSL R3 ;R2 的值左移R3 位，然后和R1相与操作，结果放入R1
  ```

  > LSL (Logical Shift Left) 逻辑左移
  > LSR (Logical Shift Right) 逻辑右移
  > ASL (Arithmetic Shift Left) 算术左移
  > ASR (Arithmetic Shift Right) 算术右移
  > ROR (Rotate Right) 循环右移
  > RRX (Rotate Right Extended by 1 Place)带扩展的循环右移，连同C标志循环右移一位。
  >
  > ![mark](http://media.sumblog.cn/blog/20190105/oaelpH5hX8Ns.png?imageslim)

- 寄存器间接寻址：利用一个寄存器的值作为存储器地址

  ```assembly
  LDR R0，[R1]
  STR	R0，[R1] 
  ```

- 变址寻址

  将基址寄存器的内容与指令中给出的偏移量相加，形成存储器的有效地址；是寄存器间接寻址的增强形式

  ```
  LDR	 R0，[R1，#4]
  LDR	 R0，[R1，#-4]
  ```

- 堆栈寻址

- 块拷贝寻址

- 相对寻址

## ARM 指令

1. 数据处理指令

   - **数据传送指令**

     - ` MOV{条件}{S}  目的寄存器，源操作数`

       ```
       	MOV	R1，R0	
       	MOV R1，R0，LSL ＃3
       ```

   - **算术运算指令**

     - ` ADD{条件}{S} 目的寄存器，操作数1，操作数2`

       ```
       	ADD 	R0，R1，R2         
       	ADD 	R0，R1，#256           
       	ADD 	R0，R2，R3，LSL#1   
       ```

     - ` ADC{条件}{S} 目的寄存器，操作数1，操作数2` 

       ADC指令用于把两个操作数相加，**再加上CPSR中的C条件标志位的值**，并将结果存放到目的寄存器中

     - ` SUB{条件}{S} 目的寄存器，操作数1，操作数2`

     - `SUBC`

     - ` AND{条件}{S} 目的寄存器，操作数1，操作数2` 

       逻辑与运算，该指令常用于屏蔽操作数1的某些位。例如：

       ```
       AND 	R0，R0，＃3 ；将高位屏蔽（取出低位）
       ```

     - `ORR{条件}{S} 目的寄存器，操作数1，操作数2`

       该指令常用于设置操作数1的某些位。

     - `  EOR{条件}{S} 目的寄存器，操作数1，操作数2` 异或，用于部分位求反

     - ` TST{条件} 操作数1，操作数2`

       TST指令用于把一个寄存器的内容和另一个寄存器的内容或立即数**进行按位的与运算**，并根据**运算结果无条件更新CPSR中条件标志位的值**。操作数1是要测试的数据，而操作数2是一个位掩码，该指令一般用来检测是否设置了特定的位。

     - `TEQ{条件} 操作数1，操作数2` 该指令通常用于比较操作数1和操作数2是否相等

     - `MUL{条件}{S} 目的寄存器，操作数1，操作数2` 

       操作数1与操作数2的乘法运算，并把**结果的低32位放置到目的寄存器**中

     - `SMULL{条件}{S}  目的寄存器Low，目的寄存器High，操作数1，操作数2  `

       结果的低32位放置到目的寄存器Low中，结果的高32位放置到目的寄存器High中

2. Load/Store

   **用于在寄存器和存储器之间传送数据**。

   - `LDR{条件} 目的寄存器，<存储器地址> `

     LDR指令用于从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。例如：

     ```
     LDR   R0，[R1] ；将内存单元[R1]中的字读取到R0寄存器中
     LDR   R0，[R1，R2] ；将内存单元[R1＋R2]中的字读取到R0寄存器中
     LDR   R0，[R1，＃8] ；将内存单元[R1+8]中的字读取到R0寄存器中
     LDR   R0，[R1，R2]！；将内存单元[R1+R2]中的字读取到R0寄存器中,同时R1←R1+R2
     ```

   - `STR{条件} 源寄存器，<存储器地址>`

     STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。

   - `SWP{条件} 目的寄存器，源寄存器1，[源寄存器2]`

     SWP指令用于将源寄存器2所指向的存储器中的字数据传送到目的寄存器中，同时将源寄存器1中的字数据传送到源寄存器2所指向的存储器中

     ```asm
     SWP R0，R1，[R2] ;R0←[R2]，[R2]←R1
     SWP R0，R0，[R2] ;R0(目的)←[R2]，[R2]← R0(源)即实现了寄存器R0的内容与存储器地址[R2]的内容的交换	
     ```

3. 跳转

   - ` B{条件}  目标地址`

     存储在跳转指令中的实际值是相对当前PC值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算。它是24位有符号数，左移两位后有符号扩展为 32位，表示的有效偏移为 26位(前后32MB的地址空间)。

     `B   Label /*程序无条件跳转到标号Label处执行*/`

   - ` BL{条件}  目标地址`

     跳转之前，**会在寄存器R14中保存PC的当前内容**，因此，可以通过将R14的内容重新加载到PC中，来返回到跳转指令之后的那个指令处执行。该指令是实现**子程序调用**的一个基本但常用的手段。

   - ` BX{条件}  目标地址`

     当前处理器工作状态使用Thumb指令集时，==通过BX指令可使当前处理器工作状态切换到ARM指令集运行状态==，反之亦然。具体状态有目标寄存器最低位决定。例如：

     ```
     ADRL  R0, ThumbFun+1
     BX  R0  ；跳转到R0指定的地址，并根  据R0最低位来切换处理器状态
     ```


## ARM 汇编

- 理解为主
- 伪操作、伪指令的特点
- 怎么定义数、变量、如何引用文件、入口、常量
- 难度类似于课件中汇编的例子
- 怎么定义一个段、end、 标号、跳转
- 汇编一定会涉及
- 绝对没有问题

## 伪操作和伪指令

- 伪操作不像机器指令那样在计算机运行期间由机器执行

- 汇编器在对源程序汇编期间由汇编程序处理

- 伪指令不是真正的ARM指令

- 伪指令在汇编编译器对源程序进行汇编处理时被替换成对应的ARM指令或指令序列

- **符号定义伪操作：**

  - 定义全局变量：GBLA（算术）、GBLL（逻辑）和GBLS （字符）

    用于定义一个ARM程序中的全局变量，并将其初始化为0（假或空），作用范围为包含该变量的源程序

    ```
    GBLA  Testl ；定义一个全局的数字变量，变量名为Testl
    Test1  SETA  oxaa ；将该变量赋值为oxaa
    
    GBLL  Test2 ；定义一个全局的逻辑变量，变量名为Test2
    Test2  SETL｛TRUE｝；将该变量赋值为真
    
    GBLS  Test3 ；定义一个全局的字符串变量，变量名为Test3
    Test3  SETS “Testing”；将该变量赋值为“Testing”
    ```

  - 定义局部变量：LCLA、LCLL和 LCLS 

  - 对变量赋值：SETA、SETL和 SETS

- **数据定义伪操作：**

  - `LTORG`: 声明一个数据缓冲池（literal pool）的开始

  - `MAP  表达式 ｛，基址寄存器｝` 用于定义一个结构化的内存表（storage map）的首地址

  - `标号  FIELD  表达式` : 用于定义一个结构化内存表中的数据域

    ```
    	 MAP   0x100  ；定义结构化内存表首地址的值为0x100
    	 A  FIELD  16 ；定义A的长度为16字节，位置为0x100
    	 B  FIELD  32 ；定义B的长度为32字节，位置为0x110
    	 S  FIELD  256；定义S的长度为256字节，位置为0x130
    ```

  - `标号   DCB  表达式` 分配一片连续的字节存储单元，并用伪操作中指定的表达式初始化

    ```
    Str  DCB “This is a test!” ；
    Str  ＝  “This is a test!” ；分配一片连续的字节存储单元并初始化
    ```

    - dcw 半字
    - dcfs 单精度浮点

- **汇编控制伪操作：**

- **段定义：**

  `AREA  段名  属性1，属性2，……` AREA伪操作用于定义一个代码段或数据段。

  - CODE属性：用于定义代码段，默认为READONLY。 

  - DATA属性：用于定义数据段，默认为READWRITE。

  - READONLY属性：指定本段为只读

  - READWRITE属性：指定本段为可读可写

  ```
  AREA  Init，CODE，READONLY；该伪操作定
  				；义了一个代码段，段名为；Init，属性为只读
  ENTRY 
  指令序列
  END
  ```

  `ENTRY` ENTRY伪操作用于指定汇编程序入口点

  - 在一个**完整的汇编程序中至少要有一个ENTRY**

  - 当有多个ENTRY时，程序的真正入口点由链接器指定

  - 在**一个源文件里最多只能有一个ENTRY**（可以没有）

  `END`  END伪操作用于通知编译器已经到了源程序的结尾。

- **引用**

  `EXPORT  标号｛［WEAK］｝`:EXPORT伪操作用于在程序中声明一个全局的标号**，该标号可在其他的文件中引用**。

  ` IMPORT  标号｛［WEAK］｝` 用于通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用

  - 无论当前源文件是否引用该标号，该标号均会被加入到当前源文件的符号表中

  `EXTERN  标号｛［WEAK］｝`==通知编译器要使用的标号在其他的源文件中定义==，但要在当前源文件中引用

  - 如果当前源文件实际并未引用该标号，该标号就不会被加入到当前源文件的符号表中。

  `GET` 引用文件

示例：

```assembly
		AREA  Init ，CODE，READONLY ；定义一个代码段
		ENTRY  		；标识程序的入口点
Start 	LDR  R0 ，=0x3FF5000 	；接下来为指令序列
		MOV  R1 ，0xFF     
		STR  R1 ，［R0］
		LDR  R0 ，=0x3FF5008
		MOV  R1 ，0x01
		STR  R1 ，［R0］
					；可以有其他段
					；数据缓冲池的位置
		END                   		；程序结束
```

子程序调用：

```assembly
			AREA  Init，CODE，READONLY
			ENTRY
start 		MOV  R0 ，#10
			MOV  R1 ，#30    
			BL   subname ；调用子程序subname
return			…… 
subname   	ADD  R0，R0，R1 ；子程序
			MOV  PC， LR    ；从子程序返回
			END

```

条件判断：

```assembly
		AREA     gcd, CODE, READONLY ALIGN=3
		ENTRY
start	CMP	R0, R1		；比较a和b大小
		SUBGT   R0, R0, R1	；if(a>b) a=a-b
		SUBLT    R1, R1, R0；if(a<b) b=b-a
		BNE	start		；if(a!=b) 跳转，继续
		MOV 	PC, LR
```

程序跳转表

```asm
		AREA  Jump，CODE，READONLY ；设置本段程序的
					；名称（Jump）及属性
num	EQU  2 		；跳转表中的子程序个数
		ENTRY        		；程序执行的入口点
Start
		MOV   r0，#0 	；设置3个参数，然后调用子程序					；arithfunc，进行算术运算
		MOV   r1，#3 
		MOV   r2，#2
		BL    arithfunc  	；调用子程序arithfunc
Stop				；程序退出
		MOV  r0， #0x18
		LDR  r1，=0x20026
		SWI  0x123456
		
Arithfunc			  ；子程序arithfunc入口点
		CMP   	r0，#num      	  ；判断选择子程序的参数是否在
					  ；有效范围之内
		MOVHS 	pc，lr   	  ；若不在，则直接返回
		ADR	r3，JumpTable   ；读取跳转表的基地址（ADR是伪指令）
		LDR	pc，[r3，r0，LSL #2] ；根据参数r0的值跳转到
						；相应的子程序
JumpTable
		DCD	DoAdd
		DCD	DoSub
DoAdd    			；子程序DoAdd执行加法操作
 		ADD	r0，r1，r2
 		MOV	pc，lr
DoSub 				；子程序DoSub执行减法操作
 		SUB	r0，r1，r2
		MOV	pc，lr
		END           		；结束汇编 


```



# 5. ARM-C

汇编和 C 传递参数的规则

- C 靠栈传递
- ARM 汇编：靠寄存器

**有关异常的处理** 

- 中断是其中的一种 **一定会涉及到** 不会特别细，理解机制

## ATPCS

> arm-thumb procedure call standard
>
> 为了使单独编译的C语言程序和汇编程序之间能够相互调用而规定的规则
>
> 规定了应用程序函数可以如何分开地写，分开地编译，最后将它们连接在一起

- ATPCS规定数据栈为FD类型

> Full   Descending  满递减，
> 对数据栈的操作是8字节对齐的。

- 参数个数可变的子程序参数传递规则：
  - ==参数不超过4个时，使用R0～R3来传递==
  - ==参数超过4个时，可以使用数据栈来传递==
- 参数个数固定的子程序参数传递规则 
  - ==第一个整数参数，通过R0～R3来传递==
  - ==其他参数通过数据栈来传递==
  - 有关浮点运算，需特别处理
- 子程序结果返回规则 
  - 结果为一个32位整数时，可以通过寄存器R0返回。
  - 结果为一个64位整数时，可以通过寄存器R0和R1返回，依次类推。



## 异常中断

1. ==复制 CPSR 到相应模式的 SPSR 寄存器中==
2. 正确设置 CPSR 寄存器各域的值 （使处理器处于对应模式）
3. ==保存返回地址到对应模式的链接寄存器== （LR）
4. ==设置当前程序计数器 PC 为中断向量地址== （跳转到相应的中断处理程序中）

**返回：**

1. 恢复 CPSR
2. LR 的值减去偏移量后存入 PC
3. 恢复普通寄存器



# 6. 硬件系统设计

**最小系统：**

- ==电源、时钟、复位、内存、调试接口==



# 7. 嵌入式（实时）操作系统

> **RTOS 概念：**
>
> 它是一个能够==在指定或确定的时间内完成系统功能，即对外部事件在同步或异步时间内作出响应的系统==
>
> **特点**：
>
> 1. **实时性**
> 2. 可移植性
> 3. 可配置、可裁剪

- 任务基本的三个状态
- 调度的策略 （抢占式、非抢占式）前后台
- 临界区、临界资源、互斥、同步
- 常见的解决互斥的手段
  - 关中断
  - 禁止任务调度 （信号量

## 任务

> 进程是资源分配的最小单位。
>
> 线程是进程内部一个相对独立的控制流，是调度执行的最小单位。

- **任务的基本状态：**
  - 运行态：该任务已获得运行所必需的资源，它的程序正在处理机上执行。    
  - 阻塞态：任务正等待着某一事件的发生而暂时停止执行。这时，即使给它CPU控制权，它也无法执行，则称该任务处于阻塞态。
  - 就绪态：任务已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行。
- **调度策略：**
  1. 何时调度：任务被创建、运行结束、被阻塞，I/O中断发生时，时钟中断发生时。
  2. **调度方式：**
     - **可抢占式**：最高优先级的任务一旦就绪，总能得到CPU的控制权。
     - **不可抢占式：**各个任务彼此合作共享一个CPU，任务主动放弃CPU的使用权。

## 共享资源

代码的临界区也称为临界区，指处理时不可分割的代码；代码一旦开始执行，则不允许任何中断打入。

临界区的保护：在进入临界区之前要关中断；临界区代码执行完以后要立即开中断。

可以被一个以上任务同时访问的资源称为共享资源或者临界资源。

**实现资源互斥访问的方法：**

| 比较项目             | 关中断                                       | 禁止任务切换                           | 使用测试并置位指令                       | 使用信号量                                     |
| -------------------- | -------------------------------------------- | -------------------------------------- | ---------------------------------------- | ---------------------------------------------- |
| 锁定范围             | 互斥粒度最强，锁定所有外部可屏蔽中断         | 锁定所有任务                           | 锁定所有使用该指令访问共享资源的代码     | 只影响竞争共享资源的任务                       |
| 对系统响应时间的影响 | 若关中断时间过长，对系统的响应性能有很大影响 | 若禁止切换时间过长，影响系统的响应性能 | 较小                                     | 对系统的响应性能有一定影响，可能导致优先级反转 |
| 系统开销             | 小                                           | 小                                     | 小                                       | 较大                                           |
| 注意事项             | 关中断时间要尽量短                           | 禁止调度的时间要尽量短                 | 不是所有处理器都支持该指令，影响可移植性 | 需要采用一定的策略解决优先级反转问题           |

## 同步与通信

同步与通信机制有：

- **信号量**：用于任务与任务之间、中断服务程序与**任务之间的同步以及任务间的互斥**
- **消息队列**：提供任务与任务之间、中断服务程序与任务之间的**通信功能**。
- **事件**（事件集）：用来通知其他任务或中断服务程序出现了一个预先定义的事件。
- 异步信号（软件中断机制）：用于任务与任务之间、中断服务程序与任务之间的异步操作。
- 管道（某些实时内核提供）：使用操作系统的I/O系统，可提供与消息队列互换的功能。



# 8. μC/OS-II  内核

- 位图算法 非常经典
- 不会考代码
- 任务调度的两种方式
  - 任务调度
  - 中断调度

## 优先级位图算法

> 每个就绪的任务都放入就绪表中（ready list）中，就绪表有两个变量：OSRdyGrp、OSRdyTbl[]

- ==**OSRdyGrp：优先级就绪组**==：这是一个8位的变量。每一个变量对应于OSRdyTbl[]中的一行
- ==**OSRdyTbl[]：优先级就绪表**==：这是一个数组，有8个成员，每个成员都是8位的变量，所以就可以构成了8*8的矩阵了

![mark](http://media.sumblog.cn/blog/20190106/MzQa0rKdMC4l.png?imageslim)

从上图可以明显看出，这个图有64个空格（64个位），每个空格对应一个数字，该数字就是优先级的标号，但是这个是人为的标上的，实际上这是64个空格，现在要做的事情就是将就绪任务的优先级相对应的标号置1，表示这个优先级任务就绪了，比如刚创建了一个任务，它的优先级是7，所以往表格中数字为7的空格写入1.就表明该优先级的任务就绪了，可以被调度了。另外当所有需要创建任务都创建完毕后，各个就绪任务的相应数字空格都会置1，表明这些任务都就绪了，比如，现在创建了5个任务，优先级分别为4,7,9,10,24.所以在创建完这些任务后，这个优先级就绪表中的相对应的数字空格都会被置1.要**特别注意上图的优先级顺序，0的优先级最高，63的优先级最低。**



- **查表实现优先级标定：**

  对于 prio = 11

  1. **把这个二进制数分为两个部分：高3位（001）和低3位（011）。**

     高三位负责找到数组中的行，低三位负责找到数组中的列（其实这里不是列，是一个变量的8个位，也可以按列理解），这样配合就可以寻址，对往相应数字标号里写1了。对上面这个数来说 001 =1说明是第1行（数组从0行开始），011=3说明在第3个位置要写入1.合在一起就是第一行的第三个位置写入1.这样就完成了对应数字优先级标号的标记。

  2.  查 ==**映射数组：OSMapTbl[]**==

     下表0对应的就是0位为1,下表1对应的就是1位为1.把这个数赋值给OSRdyGrp优先级就绪组。则OSRdyGrp哪个位为1则说明就是就绪表哪个行有就绪任务了。这样做的好处就是快。这也就是这个数组就是个映射数组，方便操作而已。

     ```
     OSRdyGrp |= OSMapTbl[prio>>3];         
     OSRdyTbl[prio>>3] |= OSMapTbl[prio&0x07];   
     ```

     prio>>3 是获取优先级的高3位，prio&0x07是获取优先级的低3位。然后在通过 OSMapTbl 的映射分别获得了就绪表中的行和就绪表中的列，

- **查表实现高优先级任务选定**

  引入 ==优先级判定表 OSUnMapTbl[]==

  ```
  High3 =OSUnMapTbl[OSRdyGrp];
  Low3  =OSUnMapTbl[OSRdyTbl[High3]];
  Prio  =(Hign3<<3)+Low3;
  ```

  ![mark](http://media.sumblog.cn/blog/20190106/pPog5Fb6d8UN.png?imageslim)

## 任务调度

> 每个任务有自己的堆栈空间。内核对任务的抢占式调度不会干扰每个任务的总的运行结果。

- **任务级的调度** 由函数OSSched()完成

- **中断级的调度** 由中断返回函数OSIntExit()完成

  1. 中断结束时调用返回函数OSIntExit()。
  2. OSIntExit()将中断嵌套计数器OSIntNesting减1。
  3. 当计数器减到0时，对就绪任务做判断，并返回到任务：

  - **时钟节拍**

    - 时钟节拍（时钟滴答）Tick，是一种定时器中断，可通过编程方式实现。
    - 时钟节拍是一种特殊的中断，是操作系统的心脏。

    1. 中断服务子程序中，首先对32位的整数OSTime加一；
    2. 对任务列表进行扫描，判断是否有延时任务已经处于就绪状态，最后进行上下文切换。







# 9. μC/OS-II  任务管理

1. 任务建立：

   `OSTaskCreate()`

   - 任务建立时机：多任务调度OSStart()开始前；其它任务执行过程中。
   - 多任务调度开始前，必须至少建立一个任务。
   - 任务不能由中断服务程序建立

2. 删除任务 `OSTaskDel(INT8U prio)`

   - 使任务返回，并处于休眠状态

   - 任务代码并不被删除，只是不再被调用

3. 改变任务优先级：`OSTaskChangePrio()`

4. 挂起、恢复任务：`OSTaskSuspend()` `OSTaskResume()`

   - 被OSTaskSuspend()函数挂起的任务只能通过调用OSTaskResume()函数来恢复

   - 任务可以挂起自己或其他任务

## 时间管理

时钟节拍实现定时中断

频率由应用程序指定（10～100次/秒）；频率越高，系统负荷越重；由OSTimeTick()实现。



# 10.μC/OS-II  通信机制

- μC/OS-II是通过**信号量、消息邮箱和消息队列**来实现任务间通信的。
- μC/OS-II将信号量、邮箱和队列统称为**事件**。
- **事件控制块**是各种事件控制函数实现的基本数据结构。

**信号量：**

信号量是用来解决进程同步与互斥问题的机制

- 建立信号量：OSSemCreate(INT16 cnt)
- 删除信号量：OSSemDel()
- 等待一个信号量：OSSemPend() （P操作）
- 释放一个信号量：OSSemPost() (V 操作)

## 优先级反转

> 在有多个任务需要使用共享资源的情况下，可能会出现高优先级任务被低优先级任务阻塞，并等待低优先级任务执行的现象；高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务，这种现象就被称为优先级反转。

**解决方案：**

1. 优先级继承：只有当占有资源的低优先级任务被阻塞时，才会提高占有资源任务的优先级；
2. 优先级天花板：不论是否发生阻塞都提升。将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级

μC/OS-II中，在处理互斥型信号量时，没有被占用的、略高于最高优先级的优先级被保留给“优先级继承优先级（PIP）”。

- 建立一个互斥型信号量 OSMutexCreate()
- 删除一个互斥型信号量 OSMutexDel()
- 等待一个互斥型信号量 OSMutexPend()
- 释放一个互斥型信号量 OSMutexPost()





消息邮箱：可以使一个任务或者中断服务程序向另一个任务发送一个指针型的变量

消息队列：可以使一个任务或者中断服务程序向另一个任务发送以指针方式定义的变量。





# 关于嵌入式考试

by 诚夏

## 题型

4类题：

- 选择 15道 30分
- 填空题 20个空 20分
- 简答题 6个题 30 分
- 程序题 20分

## 考啥

1. 概述：

   嵌入式的概念、嵌入式系统的特点、要素、区别（和单片机的区别）嵌入式处理器的分类（处理器、微控制器）嵌入式操作系统的分类、实时性的概念（不是快）（确定性）

2. 嵌入式系统简介：

   计算机两种体系结构的区别、控制器的组成方式、流水线、缓存的作用、risc cisc 区别特点（课件上的对比表）、轮询、前后台系统、事件驱动的编程模型

3. ARM 编程模型

   - ARM 命名 的三个系列的区别 （A15）A系列的代号 M3、M4 R系列
   - ARM 内部的两个状态和七种模式（用户模式、系统模式、异常模式）
   - 模式对应的多个寄存器 （16个寄存器）几种异常 （备份）（快速中断）
   - R15 PC指针、堆栈指针等

4. 指令

   - 寻址方式：
     - 与 8086 对比
     - 立即数寻址方式
     - 寄存器寻址、寄存器移位寻址
     - 间接寻址
   - **指令：**
     - 不用背
     - 考试以程序方式给出
     - 考核简单常用指令
   - 汇编：
     - 理解为主
     - 伪操作、伪指令的特点
     - 怎么定义数、变量、如何引用文件、入口、常量
     - 难度类似于课件中汇编的例子
     - 怎么定义一个段、end、 标号、跳转
     - 汇编一定会涉及
     - 绝对没有问题

5. ARM-c

   汇编和 C 传递参数的规则

   - C 靠栈传递
   - ARM 汇编：靠寄存器

   **有关异常的处理** 

   - 中断是其中的一种 **一定会涉及到** 不会特别细，理解机制

6. ARM-c 编程

7. 第八节调试没有讲，不涉及

8. 9,10 不是重点，但会涉及到，都是小题目，常识性的，

9. **重点：uCOS**

   - **11 节**
     - 任务基本的三个状态
     - 调度的策略 （抢占式、非抢占式）前后台
     - 临界区、临界资源、互斥、同步
     - 常见的解决互斥的手段
       - 关中断
       - 禁止任务调度 （信号量
   - 内核
     - 位图算法 非常经典
     - 不会考代码
     - 任务调度的两种方式
       - 任务调度
       - 中断调度
   - 多任务
     - 时钟中断 
       - time dealy 延迟
     - 任务的挂起与恢复
     - **信号量** 
       - 互斥型信号量解决优先级反转的问题

两周后的周二  1 月 8 日  321 办公室 答疑